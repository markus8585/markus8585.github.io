<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Test</title>
  <script type="text/javascript" src="jquery.min.js"></script>
  <script src="interact.js" type="text/javascript"></script>
  <style>
    html,
    body {
        margin: 0;
        padding: 0;
        position: relative;
    }
    
    body {
        height: 100vh;
        width: 100vw;
    }
    
    #stage {
        height: 100%;
        width: 100%;
        margin: 0 auto;
        border-left: 1px solid red;
        border-right: 1px solid red;
        max-width: 500px;
        position: relative;
        z-index: 1;
        background: rgba(255,255,255,.3);
    }
    
    .box {
        width: 25%;
        height: 5em;
        margin: 0;
        overflow: hidden;
        position: absolute;
        background-color: #29e;
        color: white;
        text-align: center;
        box-shadow: 0 0 10px rgba(0, 0, 0, .3);
        border-radius: 0.75em;
    }
    
    #menu {
      z-index: 2;
      position: relative;
    }
    #menu .draggable {
        background: red;
        position: relative;
        float: left;
    }
    
    #drag-me::before {
        content: "#" attr(id);
        font-weight: bold;
    }
    .container {
      position: relative;
      max-width: 500px;
      margin: 0 auto;
      height: 100%;
    }
  </style>
</head>

<body>
  <div class="container">
    <div id="menu">
        <!--<div id="drag-1" class="box draggable">
            <p> You can drag one element </p>
        </div>
        <div id="drag-2" class="box draggable">
            <p> with each pointer </p>
        </div>-->
        <div class="box draggable"></div>
        <div class="box draggable"></div>
        <div class="box draggable"></div>
    </div>
    <div id="stage"></div>
  </div>

  <script>
      /*jQuery(window).load(function($) {
          // target elements with the "draggable" class
          interact('.draggable').draggable({
              inertia: true,
              restrict: {
                  restriction: document.getElementById('stage'),
                  endOnly: true,
                  elementRect: {
                      top: 0,
                      left: 0,
                      bottom: 1,
                      right: 1
                  }
              },
              onmove: dragMoveListener,
              onend: function(event) {
                  console.log(event);
              }
          }).on('move', function(event) {
              var interaction = event.interaction;
              //interaction.pointerIsDown && 
              console.log( interaction.interacting());
              // interaction.interacting() == true when mouseOver but not triggering interaction
              if (interaction.pointerIsDown && !interaction.interacting() && event.currentTarget.getAttribute('clonable') != 'false') {
                  var original = event.currentTarget;
                  var clone = event.currentTarget.cloneNode(true);
                  // var x = clone.offsetLeft;
                  // var y = clone.offsetTop;
                  var x = original.offsetLeft;
                  var y = original.offsetTop;
                  clone.setAttribute('clonable', 'false');
                  clone.style.position = "absolute";
                  clone.style.left = original.offsetLeft + "px";
                  clone.style.top = original.offsetTop + "px";
                  document.getElementById('stage').appendChild(clone);
                  clone.textContent = 'X: '+ original.offsetLeft +' | Y: ' + original.offsetTop;
                  // original.parentElement.appendChild(clone);
                  interaction.start({
                      name: 'drag'
                  }, event.interactable, clone);
              }
          });

          function dragMoveListener (event) {
            // console.log( 8 );
            var target = event.target,
                // keep the dragged position in the data-x/data-y attributes
                // x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
                // y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
                y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                  event.target.textContent = 'X: '+ x +' | Y: ' + y;

            // translate the element


            // update the posiion attributes
            target.setAttribute('data-x', x);
            target.setAttribute('data-y', y);

            target.style.left = x + 'px';
            target.style.top = y + 'px';

            //console.log( x +' | '+ y);
              // target.textContent = 'X: '+ x +' | Y: ' + y;
          }

          function rePosition () {
            console.log('TTTT');
          }


          document.body.onkeyup = function(e){
              if(e.keyCode == 32){
                  rePosition();
              }
          }


          
      });*/











      jQuery(window).load(function($) {
          // target elements with the "draggable" class
          interact('.draggable').draggable({
              inertia: true,
              restrict: {
                  restriction: 'parent',
                  endOnly: true,
                  elementRect: {
                      top: 0,
                      left: 0,
                      bottom: 1,
                      right: 1
                  }
              },
              onmove: function(event) {
                  var target = event.target;
                  var x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                  var y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

                  target.style.webkitTransform =
                      target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';

                  target.setAttribute('data-x', x);
                  target.setAttribute('data-y', y);
              },
              onend: function(event) {
                  console.log(event);
              }
          }).on('move', function(event) {
              var interaction = event.interaction;
              if (interaction.pointerIsDown && !interaction.interacting() && event.currentTarget.getAttribute('clonable') != 'false') {
                  var original = event.currentTarget;
                  var clone = event.currentTarget.cloneNode(true);
                  var x = clone.offsetLeft;
                  var y = clone.offsetTop;
                  clone.setAttribute('clonable', 'false');
                  clone.style.position = "absolute";
                  clone.style.left = original.offsetLeft + "px";
                  clone.style.top = original.offsetTop + "px";
                  document.getElementById('stage').appendChild(clone);
                  // original.parentElement.appendChild(clone);
                  interaction.start({
                      name: 'drag'
                  }, event.interactable, clone);
              }
          });


          // enable draggables to be dropped into this
          interact('#stage').dropzone({
            // only accept elements matching this CSS selector
            accept: '.draggable',
            // Require a 75% element overlap for a drop to be possible
            overlap: 0.75,

            // listen for drop related events:

            ondropactivate: function (event) {
              // add active dropzone feedback
              event.target.classList.add('drop-active');
            },
            ondragenter: function (event) {
              var draggableElement = event.relatedTarget,
                  dropzoneElement = event.target;

              // feedback the possibility of a drop
              dropzoneElement.classList.add('drop-target');
              draggableElement.classList.add('can-drop');
              draggableElement.textContent = 'Dragged in';
            },
            ondragleave: function (event) {
              // remove the drop feedback style
              event.target.classList.remove('drop-target');
              event.relatedTarget.classList.remove('can-drop');
              event.relatedTarget.textContent = 'Dragged out';
            },
            ondrop: function (event) {
              event.relatedTarget.textContent = 'Dropped';
            },
            ondropdeactivate: function (event) {
              // remove active dropzone feedback
              event.target.classList.remove('drop-active');
              event.target.classList.remove('drop-target');
            }
          });
      });




















      /*jQuery(window).load(function ($) {
        // target elements with the "draggable" class
        interact('#menu .box')
          .draggable({
            // enable inertial throwing
            inertia: true,
            // keep the element within the area of it's parent
            restrict: {
              restriction: "parent",
              endOnly: true,
              elementRect: { top: 0, left: 0, bottom: 1, right: 1 }
            },
            // enable autoScroll
            autoScroll: false,
            onstart : function (event) {
              newEl = jQuery(event.target).clone().appendTo( "#stage" );//.querySelector('p');
              event.target = newEl;
            },

            onmove: function (event) {
            var target = jQuery(newEl),
                // keep the dragged position in the data-x/data-y attributes
                // x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
                // y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                x = (parseFloat(target.attr('data-x')) || 0) + event.dx,
                y = (parseFloat(target.attr('data-y')) || 0) + event.dy;

            // translate the element


            // update the posiion attributes
            target.attr('data-x', x);
            target.attr('data-y', y);

            target.style.left = x + 'px';
            target.style.top = y + 'px';

            //console.log( x +' | '+ y);
              // target.textContent = 'X: '+ x +' | Y: ' + y;
          },
            // call this function on every dragend event
          });
        

          function dragMoveListener (event) {
            //console.log( event );
            var target = event.target,
                // keep the dragged position in the data-x/data-y attributes
                // x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
                // y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
                y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

            // translate the element


            // update the posiion attributes
            target.setAttribute('data-x', x);
            target.setAttribute('data-y', y);

            target.style.left = x + 'px';
            target.style.top = y + 'px';

            //console.log( x +' | '+ y);
              // target.textContent = 'X: '+ x +' | Y: ' + y;
          }

          // this is used later in the resizing and gesture demos
          window.dragMoveListener = dragMoveListener;
      });*/
  </script>
</body>

</html>